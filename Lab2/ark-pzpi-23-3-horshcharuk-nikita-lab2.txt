Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 


Кафедра програмної інженерії
 


Звіт
з лабораторної роботи №2
з дисципліни «Аналіз та рефакторинг коду»






Виконав:                                                           	     Перевірив:
ст. гр. ПЗПІ-23-3                                    	       	     ст. викл. Сокорчук І. П.
Горщарук Н. С.







Харків 2025
1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень124.11.20250.1Оформлено повністю текстовий звіт230.11.20250.2Додано посилання на відео

2 ЗАВДАННЯ
     Згідно з методичними вказівками, необхідно:
1. Розробити будову програмної системи, зокрема: 
* сформулювати архітектурні рішення для серверної частини системи; 
* описати взаємодію клієнтських компонентів (веб-, мобільного, IoT-клієнта) із сервером; 
* визначити моделі, що використовуються в системі, та зв’язки між ними.
2. Створити UML-діаграму прецедентів (Use Case Diagram) для серверної частини системи Elevate:
* визначити акторів та їхні взаємодії з системою; 
* відобразити основні дії та сценарії обробки подій. 
3. Створити ER-діаграму даних: 
* визначити сутності, атрибути та ключові поля; 
* описати зв’язки між сутностями та їх типи; 
* сформувати логічну модель даних. 
4. Розробити базу даних системи, а саме: 
* спроєктувати фізичні таблиці відповідно до ER-діаграми; 
* виконати нормалізацію даних до 3NF (1NF, 2NF, 3NF) та описати її; 
* підготувати діаграму структури БД із зазначенням зв’язків та обмежень. 
5. Розробити функції роботи з БД з використанням ORM (Entity Framework Core або CoRM):
* реалізувати CRUD-операції для основних сутностей системи; 
* забезпечити доступ до БД через шар бізнес-логіки. 
6. Розробити прикладний програмний інтерфейс (API): 
* визначити тип API (REST API); 
* описати всі ендпоінти, їх методи (GET, POST, PUT, DELETE), параметри та структури запитів; 
* надати приклади відповідей сервера. 
7. Створити специфікацію API, яка повинна включати: 
* повний опис кожного ендпоінту; 
* формати запитів та відповідей; 
* приклади використання API клієнтами (мобільним, веб-, IoT). 
8. Реалізувати серверну частину системи: 
* розробити логіку обробки запитів API; 
* забезпечити коректну взаємодію з базою даних; 
* реалізувати функції авторизації та обробки Action Events. 
9. Провести тестування роботи серверної частини: 
* перевірити коректну роботу API (Postman/Swagger); 
* перевірити запис і зчитування даних з БД; 
* продемонструвати взаємодію з клієнтами (веб-/мобільним або IoT).
10.  Підготувати завершені матеріали 
* Завантажити програмний код серверної частини та БД у GitHub з коректними комітами. 
* Записати 7–9-хвилинне відео тестування API та взаємодії з БД (за потреби — з IoT/веб/мобільним клієнтом) з таймкодами ключових кроків. 
* Підготувати звіт, що містить: UML-, ER- та структурну діаграми БД, специфікацію API, інженерні рішення, фрагменти коду та посилання на відео.

3 ОПИС ВИКОНАНОЇ РОБОТИ
1. Архітектурні рішення системи
1.1. Загальна архітектура
     Система Elevate будується за багатошаровою архітектурою типу «клієнт–сервер» із додатковим IoT-компонентом.
a) Серверна частина (Backend)
1. Мова програмування: C#, платформа .NET Core.
2. Сервер виконує роль централізованого ядра системи та відповідає за:
* реалізацію бізнес-логіки командної гейміфікації (нарахування командних балів, визначення командних рівнів і видача командних бейджів учасникам);
* роботу з базою даних (ORM – Entity Framework Core);
* авторизацію та автентифікацію користувачів (JWT-токени);
* обробку подій (ActionEvents) від веб-, мобільних та IoT-клієнтів;
* побудову командних рейтингів та аналітики, а також зведених звітів за командами;
* контроль доступів відповідно до ролей (User, Manager, Admin).
b) База даних (Microsoft SQL Server)
Виступає центральним сховищем даних системи. Зберігає:
1. користувачів та їхні ролі;
2. команди та членів команд (TeamMembers), включно з їхніми командними балами та рівнями;
3. типи командних подій (ActionTypes) та журнал подій (ActionEvents);
4. командні бейджі (TeamBadges) та факти їх присвоєння користувачам у командах (UserTeamBadges);
5. IoT-пристрої, прив’язані до команд (Devices), та історію сканувань бейджів (DeviceScans);
6. службову інформацію (дати створення, статуси, блокування тощо).
c) Веб-клієнт (React + JS/HTML/CSS)
Основний робочий інтерфейс для користувачів, менеджерів та адміністраторів. Забезпечує:
1. перегляд особистого профілю в розрізі команд:
* у яких командах користувач бере участь;
* командні бали (TeamPoints) в кожній команді;
* поточний командний рівень (TeamLevel) в кожній команді;
* отримані командні бейджі (UserTeamBadges);
2. перегляд командних рейтингів (лідерборди всередині окремих команд та, за потреби, перехресні порівняння команд);
3. участь у командних челенджах, взаємне визнання (peer recognition) у межах команди;
4. адміністрування правил гейміфікації на рівні команд (для Manager/Admin):
* створення та редагування командних рівнів (TeamLevels);
* створення та редагування командних бейджів (TeamBadges);
* створення та редагування командних типів подій (ActionTypes);
5. доступ до аналітики по кожній команді (активність, бали, рівні, бейджі).
d) Мобільний клієнт (Flutter/Dart)
Спрощений адаптивний інтерфейс, який забезпечує:
1. швидкий доступ до особистого профілю в розрізі команд (список команд, бали та рівень у кожній);
2. перегляд командних рейтингів;
3. отримання push-нотифікацій про нові командні нагороди (TeamBadges), зміну командного рівня (TeamLevel), зміну позиції в командному рейтингу;
4. перегляд останніх подій (ActionEvents) та досягнень у командах користувача.
e) IoT-клієнт (ESP32 / Raspberry Pi, симуляція у Wokwi)
     IoT-компонент реалізує фізичну візуалізацію командної гейміфікації. Кожен пристрій прив’язаний до конкретної команди:
1. зчитування NFC/RFID-бейджів користувачів;
2. відображення інформації про користувача в контексті команди пристрою:
* ім’я та прізвище користувача;
* командні бали (TeamPoints) у цій команді;
* поточний командний рівень (TeamLevel);
* нещодавно отримані командні бейджі;
3. показ короткого командного рейтингу (топ користувачів у конкретній команді/офісі);
4. світлову/візуальну індикацію нових командних досягнень (отримання нового TeamBadge);
5. формування подій (ActionEvents) з джерелом IoT: після сканування бейджа користувач у рамках команди пристрою вибирає дію за допомогою фізичних кнопок (наприклад, «Приступив до роботи», «Почав перерву»). Пристрій надсилає actionCode і свій DeviceKey на сервер, де створюється відповідний запис ActionEvent із SourceType = 'IoT' та TeamID, що відповідає команді пристрою.
     Уся взаємодія клієнтів із сервером відбувається через REST API по протоколу HTTPS у форматі JSON. Авторизація – за допомогою JWT-токенів; для IoT-пристроїв використовуються окремі токени пристроїв (DeviceKey), жорстко прив’язані до команд.
1.2. Загальна діаграма класів системи Elevate
     На діаграмі (Б.1) представлено основні сутності командно-орієнтованої моделі Elevate та їхні взаємозв’язки. Система побудована навколо взаємодії користувачів у командах, де всі гейміфікаційні механіки (події, бали, рівні, бейджі) прив’язані саме до командного контексту. Основні класи моделі:
     Основні доменні моделі
1. User — Користувач – Представляє співробітника системи Elevate. Користувач має особистий обліковий запис і може:
* входити до кількох команд через сутність TeamMember;
* виконувати події в межах цих команд (ActionEvents);
* отримувати командні бейджі (UserTeamBadges) у кожній команді окремо;
* проходити сканування на IoT-пристроях, закріплених за командами (DeviceScans).
2. Team — Команда – Організаційна одиниця (відділ, проектна група тощо). Для кожної команди визначаються:
* власні командні рівні (TeamLevels);
* власні командні бейджі (TeamBadges);
* власні типи подій (ActionTypes) і фактичні події (ActionEvents);
* прив’язані IoT-пристрої (Devices).
Команда об’єднує учасників через TeamMembers і має власний внутрішній рейтинг.
3. Team Levels — Командні рівні – Набір рівнів, створений окремо для кожної команди. Кожен рівень має назву, порогову кількість командних балів і порядковий номер.
Учасники піднімаються цими рівнями саме в контексті конкретної команди на основі своїх командних балів (TeamPoints у TeamMembers).
4. Team Badges — Командні бейджі – Досягнення, які команда може вручати своїм учасникам. Кожен бейдж:
* належить лише одній команді;
* має унікальний код, назву, опис та іконку;
* містить описану умову видачі (тип умови й порогове значення).
Факти отримання фіксуються в UserTeamBadges з прив’язкою і до користувача, і до команди.
5. Events (ActionEvents) — Події – Фактичні активності користувачів у межах команд. Кожна подія завжди належить:
* конкретному користувачу (UserID);
* конкретній команді (TeamID);
* конкретному типу події (ActionTypeID).
Подія містить джерело (Manager/Peer/Automatic/IoT), коментар, нараховані бали й часові мітки, і використовується для розрахунку командних балів, рівнів і бейджів.
6. Devices — IoT-пристрої – Фізичні пристрої (наприклад, панелі з NFC/RFID-рідером), жорстко прив’язані до певної команди. Вони:
* автентифікуються на сервері за DeviceKey;
* зчитують бейджі користувачів і формують DeviceScans;
* ініціюють події з джерелом IoT та відображають коротку інформацію про користувача й командний рейтинг на екрані.
     Логічні зв’язки між моделями
* User (0..n) — (0..n) Team. Один користувач може входити до багатьох команд, і одна команда може містити багато користувачів.
* Team (1) — (0..n) TeamLevels. У кожної команди може бути кілька власних командних рівнів.
* User (0..n) — (0..n) TeamLevels. Користувачі можуть мати різні рівні в різних командах.
* Team (1) — (0..n) TeamBadges. Кожна команда визначає власний набір командних бейджів.
* User (0..n) — (0..n) TeamBadges. Один користувач може отримати багато командних бейджів, і один бейдж може бути вручений кільком користувачам.
* User (1) — (0..n) Events. Один користувач може створити багато подій.
* Team (1) — (0..n) Events. Кожна подія завжди належить одній команді.
* User (0..n) — (0..n) Devices. Користувач може взаємодіяти з багатьма пристроями, а пристрій може сканувати багато користувачів.
* Team (1) — (0..n) Devices. Кожен IoT-пристрій прив’язаний до однієї команди; команда може мати багато пристроїв.
* Devices (0..n) — (0..n) Events. Події можуть бути ініційовані пристроями, і один пристрій може створювати багато подій.
     Ці логічні моделі ляжуть в основу ER-діаграми та фізичної структури БД.
2. UML-діаграма прецедентів серверної частини
     Для опису функціональності серверної частини системи Elevate була розроблена UML-діаграма прецедентів (Б.2-Б.6). Діаграма відображає основних акторів системи та їх взаємодію з сервером через REST API.
     Основні актори:
a) User (Користувач) – працівник, який виконує робочі дії, отримує бали та переглядає свій прогрес.
1. Усі нові облікові записи після реєстрації автоматично мають роль User.
2. На цьому етапі користувач може приєднуватися до наявних команд (через запрошення/додавання менеджером) або створити власну команду.
3. Після створення своєї команди користувач отримує розширені повноваження в контексті цієї команди (див. нижче про Manager).
b) Manager (Менеджер) – керівник команди/відділу, має розширені права для перегляду аналітики та ручного нарахування балів.
1. Роль Manager призначається не при реєстрації, а внаслідок дії:
* або коли звичайний користувач створює нову команду – тоді він автоматично стає її менеджером (TeamRole = "Manager"/"Owner", а системне поле Users.Role оновлюється на "Manager");
* або коли адміністратор призначає існуючого користувача менеджером конкретної команди.
2. Менеджер завжди залишається користувачем системи, просто має додаткові права в рамках однієї чи кількох команд.
c) Admin (Адміністратор) – відповідає за конфігурацію системи, керування користувачами, командами, рівнями, бейджами та IoT-пристроями.
1. За замовчуванням при звичайній реєстрації роль Admin не видається.
2. Роль Admin отримують:
* або спеціальні системні облікові записи, створені через ініціалізаційний скрипт/міграцію;
* або існуючі користувачі, яким адміністратор із поточними правами Admin підвищує роль.
3. Таким чином, усі користувачі завжди стартують як User, а Admin – це завжди результат окремого адміністративного рішення.
d) IoT Device (IoT-пристрій) – апаратний або симульований пристрій (ESP32/Raspberry Pi з NFC/RFID та LED-дисплеєм), який звертається до серверу через API.
     Основні прецеденти
     1. Для User
a) Зареєструватися / авторизуватися в системі 
Виконується через веб- або мобільний клієнт:
1. Реєстрація нового облікового запису
* Надсилання форми з Login, Email, Password та базовими даними профілю (ім’я, прізвище).
* Перевірка унікальності Login та Email (за індексами в таблиці Users).
* Хешування паролю та створення запису в таблиці Users з роллю Role = "User" за замовчуванням.
* Ініціалізація полів IsActive = true, CreatedAt = now, LastLoginAt = null.
* Формування JWT-токена для автоматичного входу після успішної реєстрації (успішний Response від /api/auth/register).
2. Авторизація (Login)
* Надсилання Login/Email + Password.
* Перевірка облікових даних, перевірка IsActive.
* У разі успіху – генерація JWT-токена, оновлення LastLoginAt, повернення ролі користувача (User/Manager/Admin) і базових даних профілю.
3. Вихід із системи (Logout)
* На клієнті – видалення/інвалідація JWT-токена.
* На сервері – опційно логування факту виходу (для аналітики безпеки).
b) Переглядати власні дані
Користувач звертається до захищених ендпоінтів (із JWT-токеном) і може переглянути:
1. особистий профіль (ім’я, прізвище, поточна системна роль: User / Manager / Admin);
2. загальні та командні бали, поточні командні рівні;
3. список отриманих командних бейджів (UserTeamBadges);
4. історію власних подій (ActionEvents) у розрізі команд;
5. позицію в глобальних та командних рейтингах.
c) Надіслати подію / запит
1. Створити ручну подію через API (наприклад, запит на визнання досягнення або фіксацію завершення задачі, якщо немає автоматичної інтеграції).
2. На сервері створюється запис ActionEvent із відповідним SourceType (наприклад, "UserRequest") та нульовими або попередньо визначеними балами (до підтвердження менеджером).
d) Надіслати “подяку” колезі (peer recognition)
1. Створення події для іншого користувача в межах команди, де джерело – інший користувач (SourceType = "Peer", SourceUserID = поточний User).
2. На основі типу події нараховуються бали, оновлюється рейтинг і потенційно видаються командні бейджі.
e) Створити команду (підвищення ролі з User до Manager)
Це ключовий прецедент, який формалізує правило, що всі користувачі спочатку звичайні, а менеджером стають лише після створення команди:
1. Користувач з роллю User викликає, наприклад, POST /api/teams із даними нової команди (назва, опис, опціонально – тип, офіс тощо).
2. Сервер:
* створює запис у Teams;
* створює запис у TeamMembers, де:
UserID = автор запиту;
TeamRole = "Manager" або "Owner";
TeamPoints = 0, TeamLevelID = null (на старті);
* оновлює системну роль користувача в таблиці Users на Role = "Manager", якщо раніше він був лише звичайним користувачем.
3. Відтепер цей користувач, окрім базових можливостей User, отримує доступ до прецедентів Manager в контексті створеної команди.
     2. Для Manager
     Менеджер має усі прецеденти User, а також розширені можливості в командах, де він має роль Manager/Owner:
a) Переглянути активність команди
1. Перегляд сумарних балів по команді;
2. аналіз активності за вибрані періоди (день/тиждень/місяць);
3. перегляд середнього командного рівня та внутрішнього рейтингу учасників.
b) Переглянути аналітику
1. Таблиці та графіки за типами подій, користувачами, підрозділами/командами;
2. фільтри за періодами, категоріями ActionTypes, статусами подій.
c) Нарахувати бали вручну
1. Створення подій для підлеглих із джерелом "Manager" (Manual Reward).
2. Вказання коментаря (наприклад, за що саме видано додаткові бали).
3. Сервер через ActionEventService:
* знаходить ActionType;
* нараховує бали;
* оновлює TeamMembers.TeamPoints;
* перевіряє перехід на новий командний рівень і можливу видачу бейджів.
d) Керувати командою
1. Додавати/вилучати користувачів із команди через API для TeamMembers;
2. змінювати ролі в межах команди (наприклад, позначити старшого учасника як "Lead");
3. створювати й налаштовувати внутрішні челенджі (як набори ActionTypes/ActionEvents із певними умовами).
     3. Для Admin
a) Керувати користувачами
1. Створювати, редагувати та деактивувати користувачів.
2. Базове правило системи: при створенні нового користувача адміністратором він також спершу має роль User.
3. За необхідності адміністратор може:
* призначити користувачу роль Manager (наприклад, якщо його потрібно зробити керівником уже існуючої команди);
* підвищити роль до Admin (для делегування адміністративних функцій).
b) Керувати командами
1. Створювати, редагувати та видаляти записи про команди (Teams).
2. Призначати/змінювати менеджерів конкретних команд, коригуючи TeamMembers та при потребі системні ролі Users.Role.
c) Керувати правилами гейміфікації
1. Налаштовувати ActionTypes (типи подій) для кожної команди;
2. задавати та змінювати Levels (рівні за балами) – як глобально, так і для конкретних команд;
3. налаштовувати Badges (умови отримання бейджів, порогові значення, категорії).
d) Керувати IoT-пристроями
1. Реєструвати нові пристрої (Devices), видавати їм унікальний DeviceKey;
2. змінювати статус (активний/деактивований), розташування, прив’язку до команд.
e) Контролювати безпеку
1. Переглядати логи подій та сканувань (ActionEvents, DeviceScans та службові таблиці логів, якщо є);
2. блокувати підозрілих користувачів (IsActive = false або IsBlocked = true у Users);
3. за потреби – змінювати ролі користувача (наприклад, знизити Manager назад до User або відняти Admin-права).
     4. Для IoT Device
     IoT-пристрій є окремим актором системи Elevate та взаємодіє із серверною частиною через REST API, використовуючи виданий йому унікальний DeviceKey. Основна функція пристрою — фіксація активностей користувачів через сканування NFC/RFID-бейджів та відображення командної інформації на фізичному дисплеї. Нижче наведені його ключові прецеденти.
     1. Автентифікуватися на сервері
* При кожному зверненні пристрій передає свій DeviceKey.
* Сервер перевіряє валідність ключа, чи прив'язаний пристрій до певної команди, а також стан Devices.IsActive.
* У разі успішної автентифікації оновлюється час останнього звернення (LastSeenAt), а запит дозволяється до подальшої обробки.
* Усі інші IoT-прецеденти логічно залежать від цього (виконуються лише після автентифікації).
     2. Надіслати ID бейджа (NFC/RFID)
* Пристрій зчитує UID картки/бейджа користувача й надсилає його разом з DeviceKey.
* Сервер звіряє UID із таблицею користувачів (Users) і визначає відповідного користувача.
* Одночасно система перевіряє відповідність контексту команди: користувач повинен входити до команди, до якої прив’язаний пристрій.
* Результат сканування фіксується у таблиці DeviceScans (DeviceID, UserID, TeamID, час).
* Якщо UID не належить жодному користувачу, сервер повертає відповідну помилку (наприклад, “Unknown Badge”).
     3. Отримати коротку інформацію про користувача
     Після успішного сканування пристрій може запросити так званий короткий профіль користувача в контексті команди пристрою.
Сервер повертає:
* ім’я та прізвище користувача;
* командний рівень у цій команді;
* кількість командних балів (TeamPoints);
* останні командні бейджі, отримані в команді;
* позицію в командному рейтингу.
     Ця інформація відображається на LED-/LCD-дисплеї пристрою, забезпечуючи швидкий зворотний зв’язок у реальному часі (наприклад: “+10 points”, “Level Up!”, “New Badge Earned”).
     4. Отримати дані для командної дошки (Team Leaderboard Snapshot)
     IoT-пристрій може також виконувати роль фізичної командної панелі та відображати ключові показники команди. Для цього він запитує на сервері:
* топ-N учасників команди (найчастіше топ-5 або топ-10),
* рейтинги за період (день, тиждень, місяць — за потреби),
* сумарний прогрес команди: загальна кількість балів, середній рівень учасників, кількість активних подій.
     Такі дані використовуються для візуалізації командної динаміки на екрані пристрою, що підсилює ефект гейміфікації в офісі.
     5. Надіслати дію через IoT (IoT Action)
     Якщо пристрій оснащений кнопками/тачінтерфейсом, після сканування користувач може вибрати дію (наприклад, “Почав зміну”, “Перерва”, “Завершив задачу”). Пристрій надсилає:
* DeviceKey,
* UID користувача,
* код дії (actionCode).
     Сервер створює ActionEvent з джерелом "IoT", нараховує бали, оновлює рівні та бейджі, а пристрою повертає коротке повідомлення-підтвердження.
     6. Надіслати health-перевірку та отримати конфігурацію
     Для підтримки надійної роботи пристрій може:
* надсилати health-check (стан мережі, помилки датчиків, uptime, версія прошивки);
* запитувати оновлену конфігурацію (список IoT-доступних подій, режими індикації, частота оновлення, параметри світлових ефектів).
     Це дозволяє адміністраторам контролювати статус фізичних пристроїв і централізовано оновлювати їх поведінку.
     На UML-діаграмах прецедентів актори розміщені зліва/справа від системи «Elevate Server», а всередині системи зображені прецеденти (Use Cases), що відповідають переліченим діям.
     Окремо виділено логіку життєвого циклу ролей: усі користувачі створюються з роллю User; підвищення до Manager відбувається при створенні або призначенні керівником команди, а роль Admin надається лише явним адміністративним рішенням.
3. ER-діаграма даних
     Для системи Elevate була побудована ER-діаграма (рис. Б.7), яка відображає основні сутності, їх атрибути та зв’язки між ними.
* Користувачі (Users) – зберігають дані про облікові записи працівників: ідентифікатор користувача, логін, email, хеш паролю, ім’я, прізвище, роль у системі та стан активності.
* Команди (Teams) – описують команду/відділ: ідентифікатор команди, назву, опис та службові дати.
* Командні рівні (TeamLevels) – набір рівнів усередині кожної команди з пороговою кількістю балів та порядком відображення.
* Командні бейджі (TeamBadges) – нагороди, що налаштовуються окремо для кожної команди (код, назва, опис, умова отримання).
* Події (ActionEvents / ActionTypes) – фактичні дії користувачів у командах та довідник типів цих дій з кількістю балів.
* Пристрої (Devices / DeviceScans) – IoT-пристрої, прив’язані до команд, та журнал їх сканувань бейджів користувачів.
     Зв’язки на діаграмі показують:
* зв’язок «багато-до-багатьох» між Користувачами та Командами, який реалізовано через проміжну сутність TeamMembers (участь користувача в кількох командах із власними командними балами та рівнем);
* зв’язок між Командами та їх Командними рівнями та Командними бейджами («один-до-багатьох»);
* зв’язок між Користувачами і Командними бейджами через сутність UserTeamBadges, що фіксує факт вручення бейджа в конкретній команді;
* зв’язок «користувач – команда – тип події» у сутності ActionEvents, де кожна подія належить одному користувачу, одній команді та одному типу події;
* зв’язок між Командами та Пристроями («одна команда – багато пристроїв») і між Пристроями та Користувачами через DeviceScans, що відображає історію сканувань.
     Таким чином ER-діаграма наочно демонструє командно-орієнтовану модель системи: усі гейміфікаційні механіки (події, бали, рівні, бейджі, IoT-сканування) прив’язані до користувачів у контексті конкретних команд.
4. Проєктування БД та нормалізація
     Фізична структура БД реалізована в Microsoft SQL Server за допомогою T-SQL-скрипту. Для кожної логічної сутності створено окрему таблицю, первинні ключі – автоінкрементні поля INT IDENTITY, зв’язки – через зовнішні ключі з необхідними каскадними правилами.
     Основні таблиці:
* Users(UserID, Login, Email, PasswordHash, FirstName, LastName, Role, IsActive, CreatedAt, LastLoginAt)
* Teams(TeamID, Name, Description, CreatedAt)
* TeamLevels(TeamLevelID, TeamID, Name, RequiredPoints, OrderIndex)
* TeamMembers(TeamMemberID, TeamID, UserID, TeamRole, TeamLevelID, TeamPoints, JoinedAt)
* TeamBadges(TeamBadgeID, TeamID, Code, Name, Description, IconCode, ConditionType, ConditionValue)
* UserTeamBadges(UserTeamBadgeID, UserID, TeamBadgeID, TeamID, AwardedAt)
* ActionTypes(ActionTypeID, TeamID, Code, Name, Description, DefaultPoints, Category, IsActive)
* ActionEvents(ActionEventID, UserID, TeamID, ActionTypeID, SourceType, SourceUserID, Comment, PointsAwarded, OccurredAt, CreatedAt, IsValid)
* Devices(DeviceID, Name, TeamID, DeviceKey, Location, IsActive, LastSeenAt)
* DeviceScans(DeviceScanID, DeviceID, TeamID, UserID, ScannedAt)
     1NF
* усі поля містять атомарні значення;
* множинні зв’язки реалізовані окремими таблицями (TeamMembers, UserTeamBadges), а не списками ID в одному стовпці.
     2NF
     Таблиці з можливими складеними ключами (TeamMembers, UserTeamBadges) отримали штучні сурогатні PK (TeamMemberID, UserTeamBadgeID). Усі неключові атрибути залежать від усього первинного ключа, тому часткових залежностей немає.
     3NF – приклади нормалізації
Приклад 1. ActionEvents
Ненормалізований варіант:
ActionEvents(
  ActionEventID,
  UserID,
  UserFullName,
  TeamID,
  TeamName,
  ActionTypeID,
  ActionTypeCode,
  ActionTypeName,
  PointsAwarded,
  OccurredAt,
  CreatedAt
)
     Проблеми:
* дублювання UserFullName, TeamName, ActionTypeName, ActionTypeCode;
* транзитивні залежності (ActionTypeName залежить від ActionTypeID/Code, а не від ActionEventID).
     Нормалізовано:
Users(UserID, FirstName, LastName, ...)
Teams(TeamID, Name, ...)
ActionTypes(ActionTypeID, TeamID, Code, Name, ...)
ActionEvents(ActionEventID, UserID, TeamID, ActionTypeID, SourceType, SourceUserID, PointsAwarded, OccurredAt, CreatedAt, IsValid)
     У таблиці ActionEvents залишаються тільки фактичні дані про подію, а довідникова інформація зберігається в окремих таблицях.
Приклад 2. UserTeamBadges
Ненормалізований варіант:
UserTeamBadges(
  UserTeamBadgeID,
  UserID,
  UserFullName,
  TeamID,
  TeamName,
  TeamBadgeID,
  BadgeCode,
  BadgeName,
  BadgeDescription,
  AwardedAt
)
     Нормалізований варіант:
Users(UserID, FirstName, LastName, ...)
Teams(TeamID, Name, ...)
TeamBadges(TeamBadgeID, TeamID, Code, Name, Description, ...)
UserTeamBadges(UserTeamBadgeID, UserID, TeamBadgeID, TeamID, AwardedAt)
     Таким чином, таблиці відповідають 3NF, дублювання мінімізоване.
5. Діаграма структури бази даних
     Фізична діаграма БД була побудована в середовищі SQL Server Management Studio (SSMS) на основі створених таблиць і зовнішніх ключів. На діаграмі наочно відображено:
* усі таблиці фізичної схеми: Users, Teams, TeamLevels, TeamBadges, TeamMembers, UserTeamBadges, ActionTypes, ActionEvents, Devices, DeviceScans;
* склад кожної таблиці – перелік стовпців з типами даних, позначенням PK (primary key) та FK (foreign key);
* зв’язки між таблицями у вигляді ліній із позначками ключів, що показують, яка таблиця є батьківською, а яка – підлеглою.
     На діаграмі чітко видно основні напрямки зв’язків:
* таблиця Users пов’язана з TeamMembers, ActionEvents, UserTeamBadges та DeviceScans, що відображає участь користувача в командах, подіях, отриманні бейджів і скануваннях на пристроях;
* таблиця Teams є центральною для командної логіки: має зв’язки з TeamLevels, TeamBadges, TeamMembers, ActionEvents, ActionTypes та Devices;
* таблиця TeamLevels пов’язана з Teams (одна команда – багато рівнів) і TeamMembers (багато учасників можуть мати один рівень);
* таблиця TeamBadges пов’язана з Teams та UserTeamBadges, що дозволяє фіксувати факти вручення конкретного командного бейджа конкретному користувачу;
* таблиця ActionEvents пов’язана з Users, Teams та ActionTypes, що відображає приналежність кожної події до користувача, команди та типу події;
* таблиця Devices пов’язана з Teams (пристрій належить одній команді) та DeviceScans (пристрій виконує багато сканувань), а DeviceScans, у свою чергу, пов’язана з Users, фіксуючи історію сканувань бейджів користувачів.
     Окрім структури зв’язків, на діаграмі враховані обмеження цілісності даних:
* для всіх зовнішніх ключів задані правила ON DELETE / ON UPDATE (каскадне видалення або заборона, залежно від бізнес-логіки – наприклад, видалення команди тягне за собою видалення пов’язаних TeamMembers і TeamLevels, але не видаляє користувачів);
* первинні ключі реалізовані як INT IDENTITY, що забезпечує унікальність записів у кожній таблиці.
     Також у схемі передбачені індекси, що оптимізують пошук і гарантують унікальність:
* унікальні індекси на Users.Login та Users.Email,
* унікальний індекс на Devices.DeviceKey,
* унікальний індекс на TeamBadges.Code в межах команди,
* комбінований унікальний індекс на UserTeamBadges(UserID, TeamBadgeID, TeamID), що запобігає повторній видачі одного й того самого бейджа тому самому користувачу в одній команді.
     Таким чином, діаграма структури БД не лише візуалізує всі таблиці та їх атрибути, але й демонструє реальні фізичні зв’язки, ключі та обмеження, які забезпечують цілісність і узгодженість даних у системі Elevate.
6. Функції роботи з БД (ORM)
     Для доступу до SQL Server використовується Entity Framework Core. У проекті визначено контекст:
public class ElevateDbContext : DbContext
{
    public ElevateDbContext(DbContextOptions<ElevateDbContext> options)
        : base(options) { }

    public DbSet<User> Users => Set<User>();
    public DbSet<Team> Teams => Set<Team>();
    public DbSet<TeamMember> TeamMembers => Set<TeamMember>();
    public DbSet<TeamLevel> TeamLevels => Set<TeamLevel>();
    public DbSet<TeamBadge> TeamBadges => Set<TeamBadge>();
    public DbSet<UserTeamBadge> UserTeamBadges => Set<UserTeamBadge>();
    public DbSet<ActionType> ActionTypes => Set<ActionType>();
    public DbSet<ActionEvent> ActionEvents => Set<ActionEvent>();
    public DbSet<Device> Devices => Set<Device>();
    public DbSet<DeviceScan> DeviceScans => Set<DeviceScan>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>()
            .HasIndex(u => u.Login).IsUnique();

        modelBuilder.Entity<User>()
            .HasIndex(u => u.Email).IsUnique();

        modelBuilder.Entity<TeamMember>()
            .HasOne(tm => tm.Team)
            .WithMany(t => t.TeamMembers)
            .HasForeignKey(tm => tm.TeamID)
            .OnDelete(DeleteBehavior.Cascade);

        modelBuilder.Entity<TeamMember>()
            .HasOne(tm => tm.User)
            .WithMany(u => u.TeamMembers)
            .HasForeignKey(tm => tm.UserID)
            .OnDelete(DeleteBehavior.Cascade);

        modelBuilder.Entity<UserTeamBadge>()
            .HasIndex(utb => new { utb.UserID, utb.TeamBadgeID, utb.TeamID })
            .IsUnique();

        modelBuilder.Entity<ActionEvent>()
            .HasOne(a => a.User)
            .WithMany(u => u.ActionEvents)
            .HasForeignKey(a => a.UserID)
            .OnDelete(DeleteBehavior.Cascade);

        modelBuilder.Entity<ActionEvent>()
            .HasOne(a => a.Team)
            .WithMany(t => t.ActionEvents)
            .HasForeignKey(a => a.TeamID)
            .OnDelete(DeleteBehavior.Cascade);

        // інші Fluent API-налаштування згідно зі схемою...
    }
}
     Приклад сутностей (C# / EF Core)
public class User
{
    public int UserID { get; set; }
    public string Login { get; set; } = null!;
    public string Email { get; set; } = null!;
    public string PasswordHash { get; set; } = null!;
    public string FirstName { get; set; } = null!;
    public string LastName { get; set; } = null!;
    public string Role { get; set; } = "User";
    public bool IsActive { get; set; } = true;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime? LastLoginAt { get; set; }

    public ICollection<TeamMember> TeamMembers { get; set; } = new List<TeamMember>();
    public ICollection<UserTeamBadge> UserTeamBadges { get; set; } = new List<UserTeamBadge>();
    public ICollection<ActionEvent> ActionEvents { get; set; } = new List<ActionEvent>();
    public ICollection<DeviceScan> DeviceScans { get; set; } = new List<DeviceScan>();
}

public class TeamMember
{
    public int TeamMemberID { get; set; }
    public int TeamID { get; set; }
    public int UserID { get; set; }
    public string TeamRole { get; set; } = "Member";
    public int? TeamLevelID { get; set; }
    public int TeamPoints { get; set; } = 0;
    public DateTime JoinedAt { get; set; } = DateTime.UtcNow;

    public Team Team { get; set; } = null!;
    public User User { get; set; } = null!;
    public TeamLevel? TeamLevel { get; set; }
}
     (інші класи – TeamLevel, TeamBadge, UserTeamBadge, ActionType, ActionEvent, Device, DeviceScan – реалізуються аналогічно згідно зі структурою таблиць.)
     Приклад сервісу нарахування командних балів
public class ActionEventService
{
    private readonly ElevateDbContext _db;

    public ActionEventService(ElevateDbContext db)
    {
        _db = db;
    }

    public async Task<ActionEvent> CreateAsync(
        int userId,
        int teamId,
        int actionTypeId,
        string sourceType,
        int? sourceUserId = null,
        string? comment = null,
        CancellationToken ct = default)
    {
        var actionType = await _db.ActionTypes
            .FirstOrDefaultAsync(at => at.ActionTypeID == actionTypeId
                                    && at.TeamID == teamId
                                    && at.IsActive, ct);

        if (actionType == null)
            throw new InvalidOperationException("Invalid action type for this team");

        var points = actionType.DefaultPoints;

        var actionEvent = new ActionEvent
        {
            UserID = userId,
            TeamID = teamId,
            ActionTypeID = actionTypeId,
            SourceType = sourceType,
            SourceUserID = sourceUserId,
            Comment = comment,
            PointsAwarded = points
        };

        _db.ActionEvents.Add(actionEvent);

        // оновлюємо командні бали користувача
        var teamMember = await _db.TeamMembers
            .FirstOrDefaultAsync(tm => tm.TeamID == teamId && tm.UserID == userId, ct);

        if (teamMember != null)
        {
            teamMember.TeamPoints += points;

            var newLevel = await _db.TeamLevels
                .Where(l => l.TeamID == teamId && teamMember.TeamPoints >= l.RequiredPoints)
                .OrderByDescending(l => l.RequiredPoints)
                .FirstOrDefaultAsync(ct);

            if (newLevel != null)
                teamMember.TeamLevelID = newLevel.TeamLevelID;
        }

        await _db.SaveChangesAsync(ct);
        return actionEvent;
    }
}
7. Розробка API для взаємодії серверної частини з клієнтами
     Серверна частина системи Elevate надає єдиний програмний інтерфейс для веб-клієнта, мобільного застосунку та IoT-пристроїв. Взаємодія побудована на основі HTTP-запитів до REST-ендпоінтів.
* Тип API: REST.
* Транспорт: HTTPS.
* Формат даних: JSON у тілі запиту та відповіді.
* Авторизація користувачів: JWT (JSON Web Token), заголовок
Authorization: Bearer {token}.
* Авторизація IoT-пристроїв: передача унікального DeviceKey у тілі запиту або в заголовку (наприклад, X-Device-Key).
     Вибір REST продиктований простотою інтеграції з веб- та мобільними клієнтами, наявністю стандартних інструментів (Swagger / OpenAPI, Postman) та відсутністю необхідності у двонаправленому стрімінгу, характерному для gRPC.
     Структура URL та групування ендпоінтів
     Базовий префікс для всіх ендпоінтів: /api/....
Основні групи:
1. Авторизація – /api/auth/...
2. Команди та рейтинги – /api/teams/...
3. Події та типи подій – /api/teams/{teamId}/actions, /api/teams/{teamId}/action-types
4. Командні рівні та бейджі – /api/teams/{teamId}/levels, /api/teams/{teamId}/badges, /api/users/{userId}/team-badges
5. IoT-інтеграція – /api/iot/...
Перелік основних ендпоінтів
1. Авторизація
* POST /api/auth/login
Метод: POST 
Призначення: автентифікація користувача.
Параметри тіла: логін/email, пароль.
* POST /api/auth/register
Метод: POST
Призначення: реєстрація нового користувача з початковою роллю User та одночасний вхід.
Параметри тіла: логін, email, пароль, ім’я, прізвище.
2. Команди
* GET /api/teams
Метод: GET
Призначення: отримати список усіх команд.
Параметри запиту (опційно): search, page, pageSize.
* GET /api/teams/{teamId}/leaderboard
Метод: GET
Призначення: отримати рейтинг користувачів у конкретній команді на
основі TeamMembers.TeamPoints.
Параметри шляху: teamId.
Параметри запиту (опційно): період (period=day|week|month), обмеження кількості (topN).
3. Події
* GET /api/teams/{teamId}/action-types
Метод: GET
Призначення: отримати список дозволених типів подій для команди.
Параметри шляху: teamId.
* POST /api/teams/{teamId}/actions
Метод: POST
Призначення: створення нової події (ActionEvent) у команді (від користувача, менеджера або IoT-джерела).
Параметри шляху: teamId.
Параметри тіла: userId, actionTypeId, sourceType, sourceUserId (опційно), коментар, час події.
4. Командні рівні та бейджі
* GET /api/teams/{teamId}/levels
Метод: GET
Призначення: отримати налаштовані рівні для вказаної команди.
Параметри шляху: teamId.
* GET /api/teams/{teamId}/badges
Метод: GET
Призначення: отримати список командних бейджів.
Параметри шляху: teamId.
* GET /api/users/{userId}/team-badges
Метод: GET
Призначення: отримати бейджі, отримані користувачем у конкретній команді.
Параметри шляху: userId.
Параметри запиту: teamId.
5. IoT-інтеграція
* POST /api/iot/scan
Метод: POST
Призначення: прийом скану NFC/RFID-бейджа від пристрою; логування сканування та повернення короткої інформації про користувача.
Параметри тіла: deviceKey, badgeUid або userId.
* GET /api/iot/leaderboard
Метод: GET
Призначення: отримати скорочений лідерборд та зведені дані для відображення на фізичній панелі.
Параметри запиту: teamId, опційно topN, period.
8. Створити специфікацію розробленого API
     У цьому розділі наводиться деталізована специфікація ключових ендпоінтів: опис, формат запитів і відповідей, а також приклади використання.
1. Авторизація
     POST /api/auth/login
     Опис: 
     Виконує автентифікацію користувача за логіном або email та паролем. У разі успіху повертає JWT-токен і базову інформацію про користувача.
     Запит (JSON):
{
  "loginOrEmail": "user@example.com",
  "password": "Password123"
}
     Успішна відповідь 200 OK:
{
  "userId": 5,
  "firstName": "Ivan",
  "lastName": "Ivanenko",
  "role": "User",
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 3600
}
     Можливі коди відповіді:
* 200 OK – успішна авторизація;
* 401 Unauthorized – невірний логін або пароль.
     POST /api/auth/register
     Опис:
     Створює нового користувача з початковою роллю User, зберігає його в БД і одразу повертає JWT-токен для входу.
     Запит (JSON):
{
  "login": "ivan",
  "email": "ivan@example.com",
  "password": "StrongPassword123",
  "firstName": "Ivan",
  "lastName": "Ivanenko"
}
     Успішна відповідь 200 OK:
{
  "userId": 6,
  "firstName": "Ivan",
  "lastName": "Ivanenko",
  "role": "User",
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 3600
}
     Можливі коди відповіді:
* 200 OK – користувача створено;
* 400 Bad Request – логін або email вже існують, помилка валідації.
2. Команди
     GET /api/teams
     Опис:
     Повертає список усіх команд, доступних користувачу (можна розширити фільтрацією/пагінацією).
     Приклад відповіді 200 OK:
[
  {
    "id": 1,
    "name": "Backend Team",
    "description": "Core API development",
    "createdAt": "2025-01-10T09:00:00Z"
  },
  {
    "id": 2,
    "name": "Support Team",
    "description": "Customer support",
    "createdAt": "2025-01-12T08:30:00Z"
  }
]
     GET /api/teams/{teamId}/leaderboard
     Опис:
     Повертає рейтинг користувачів у конкретній команді, відсортований за кількістю командних балів.
     Приклад відповіді 200 OK:
[
  {
    "userId": 5,
    "firstName": "Ivan",
    "lastName": "Ivanenko",
    "teamPoints": 260,
    "teamLevelName": "Level 3: Stable Performer",
    "position": 1
  },
  {
    "userId": 7,
    "firstName": "Olena",
    "lastName": "Koval",
    "teamPoints": 230,
    "teamLevelName": "Level 2: Growing",
    "position": 2
  }
]
3. Події
     GET /api/teams/{teamId}/action-types
     Опис:
     Повертає довідник типів подій для команди, включно з кількістю балів, які буде нараховано за кожен тип.
     Відповідь 200 OK:
[
  {
    "id": 1,
    "code": "TASK_DONE",
    "name": "Task completed",
    "description": "Finishing planned task",
    "defaultPoints": 10,
    "category": "Productivity",
    "isActive": true
  }
]
     POST /api/teams/{teamId}/actions
     Опис:
     Створює нову подію (ActionEvent) в межах команди. Кількість балів береться з відповідного ActionType.DefaultPoints. Після створення події оновлюються командні бали користувача та, за потреби, командний рівень і бейджі.
     Запит (JSON):
{
  "userId": 5,
  "actionTypeId": 2,
  "sourceType": "Manager",
  "sourceUserId": 3,
  "comment": "Helped with production deployment",
  "occurredAt": "2025-11-24T10:30:00Z"
}
     Успішна відповідь 201 Created:
{
  "id": 101,
  "userId": 5,
  "teamId": 1,
  "actionTypeId": 2,
  "pointsAwarded": 10,
  "occurredAt": "2025-11-24T10:30:00Z",
  "createdAt": "2025-11-24T10:30:05Z",
  "teamPoints": 260,
  "newTeamLevel": "Level 3: Stable Performer",
  "newTeamBadges": [
    "Consistency Star"
  ]
}
     Можливі коди відповіді:
* 201 Created – подію створено;
* 400 Bad Request – некоректний запит;
* 404 Not Found – команда або тип події не знайдені.
4. Командні рівні та бейджі
     GET /api/teams/{teamId}/levels
     Опис:
     Повертає список усіх рівнів, налаштованих для вказаної команди.
     Відповідь 200 OK:
[
  {
    "id": 1,
    "name": "Level 1: Newcomer",
    "requiredPoints": 0,
    "orderIndex": 1
  },
  {
    "id": 2,
    "name": "Level 2: Growing",
    "requiredPoints": 100,
    "orderIndex": 2
  }
]
     GET /api/teams/{teamId}/badges
     Опис:
     Повертає всі командні бейджі, які можуть бути видані учасникам команди.
     Відповідь 200 OK:
[
  {
    "id": 1,
    "code": "CONSISTENCY_STAR",
    "name": "Consistency Star",
    "description": "Stable performance over 3 months",
    "iconCode": "star",
    "conditionType": "TotalPoints",
    "conditionValue": 200
  }
]
     GET /api/users/{userId}/team-badges?teamId={teamId}
     Опис:
     Повертає список командних бейджів, які конкретний користувач уже отримав у заданій команді.
     Відповідь 200 OK:
[
  {
    "teamBadgeId": 1,
    "code": "CONSISTENCY_STAR",
    "name": "Consistency Star",
    "awardedAt": "2025-11-20T09:15:00Z"
  }
]
5. IoT-ендпоінти
     POST /api/iot/scan
     Опис:
     Приймає скан NFC/RFID-бейджа від IoT-пристрою. Після успішної перевірки deviceKey та UID бейджа створюється запис у DeviceScans і повертається коротка інформація про користувача.
     Запит (JSON):
{
  "deviceKey": "DEVICE-123-KEY",
  "badgeUid": "04A1B2C3D4"
}
     Відповідь 200 OK:
{
  "userId": 5,
  "firstName": "Ivan",
  "lastName": "Ivanenko",
  "teamId": 1,
  "teamPoints": 260,
  "teamLevelName": "Level 3: Stable Performer",
  "recentBadges": [
    "Consistency Star"
  ]
}
     GET /api/iot/leaderboard?teamId={teamId}
     Опис: 
     Повертає скорочений лідерборд команди для відображення на фізичному дисплеї IoT-пристрою.
     Відповідь 200 OK:
{
  "teamId": 1,
  "topUsers": [
    {
      "userId": 5,
      "fullName": "Ivan Ivanenko",
      "teamPoints": 260,
      "teamLevelName": "Level 3: Stable Performer"
    },
    {
      "userId": 7,
      "fullName": "Olena Koval",
      "teamPoints": 230,
      "teamLevelName": "Level 2: Growing"
    }
  ],
  "totalTeamPoints": 1450
}
9. Перевірка роботи серверної частини
1. Запуск серверу – без змін (ASP.NET Core).
2. Тестування API (Swagger):
* POST /api/auth/login – отримати JWT-токен.
* POST /api/teams/{teamId}/actions – створити події для користувачів у визначеній команді.
* GET /api/teams/{teamId}/leaderboard – перевірити, що використовуються TeamMembers.TeamPoints.
* GET /api/users/{id}/team-badges?teamId=... – перевірити отримані бейджі.
3. Перевірка БД в SQL Server Management Studio:
* перегляд таблиць Users, TeamMembers, TeamLevels, TeamBadges, UserTeamBadges, ActionEvents, Devices, DeviceScans;
* перевірка:
* при створенні події додається запис у ActionEvents;
* поле TeamPoints у відповідному TeamMembers збільшується;
* при досягненні порогу командного рівня оновлюється TeamLevelID;
* при виконанні умов командних бейджів з’являються записи у UserTeamBadges.
4. Тестування IoT-сценаріїв:
* вставка запису в Devices з валідним DeviceKey та TeamID;
* виклик POST /api/iot/scan з DeviceKey і ідентифікатором користувача;
* перевірка, що:
* у DeviceScans створюється новий запис з правильним TeamID;
* відповідь API містить короткий профіль користувача в контексті команди: ім’я, командний рівень, бали, останні командні бейджі.
     Результати тестування показали, що взаємодія між REST API, бізнес-логікою (сервісами) та базою даних працює коректно і відповідає описаним у Vision & Scope сценаріям системи Elevate.



4 ВИСНОВКИ
     У межах даного завдання було спроєктовано та реалізовано серверну частину системи командної гейміфікації Elevate, а також підготовлено повний набір супровідних артефактів проєктування та документації. Робота охопила всі етапи – від архітектурних рішень і моделювання даних до розробки REST API та його тестування.
     У результаті було виконано:
* сформульовано архітектурні рішення: багатошарова клієнт–серверна архітектура з окремим IoT-компонентом, виділенням серверного ядра, БД, веб-, мобільного та IoT-клієнтів;
* розроблено UML-діаграму прецедентів, що описує взаємодію акторів (User, Manager, Admin, IoT Device) із сервером і відображає життєвий цикл ролей користувачів;
* побудовано ER-діаграму та логічну модель даних, на основі яких спроєктовано фізичну схему БД у SQL Server;
* виконано нормалізацію до 3NF, що дозволило уникнути надлишковості та забезпечити цілісність даних;
* реалізовано фізичні таблиці та діаграму структури БД з усіма зв’язками, первинними/зовнішніми ключами та індексами;
* створено шар доступу до даних з використанням Entity Framework Core, включно з доменними сутностями, DbContext та бізнес-сервісами (наприклад, сервіс нарахування командних балів);
* спроєктовано та описано REST API: визначено групи ендпоінтів (авторизація, команди, події, рівні, бейджі, IoT), їхні методи, параметри та маршрути;
* підготовлено детальну специфікацію API з форматами запитів і відповідей та прикладами використання з боку веб-, мобільного та IoT-клієнтів;
* реалізовано логіку обробки запитів (у тому числі AuthController, роботу з ActionEvents) та забезпечено коректну взаємодію з БД;
* проведено тестування через Swagger і SQL Server Management Studio, підтверджено коректність CRUD-операцій, оновлення балів, рівнів, бейджів, а також IoT-сценаріїв (сканування бейджів, виведення рейтингу).
     Отримані результати демонструють повний цикл розробки серверної частини реалістичної інформаційної системи: від моделювання предметної області й проєктування БД до створення продуманого REST API, його специфікації та інтеграції з клієнтами. Виконана робота сприяла закріпленню практичних навичок системного проєктування, роботи з ORM, побудови веб-сервісів та документування програмних інтерфейсів, що є ключовими компетенціями в галузі програмної інженерії.



5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. ДСТУ 8302:2015. Бібліографічне посилання. Загальні положення та правила складання.
2. Vision & Scope документ для програмної системи “Elevate”
3. Microsoft .NET Documentation: ASP.NET Core, Entity Framework Core – https://learn.microsoft.com/en-us/dotnet/

ДОДАТОК А
Відеозапис
Відеозапис лабораторної роботи: https://www.youtube.com/watch?v=yzxe2BGX5xg

Хронологічний опис відеозапису:
0:00 — Вступ. 
0:25 — Запит на регістрацію. 
1:20 — Запит на авторизацію. 
2:00 — Запит на поточний профіль. 
2:20 — Запит на профіль користувача за ID. 
3:25 — Запит на список команд. 
4:00 — Запит на інформацію про команду за ID. 
5:20 — Запит на учасників команди за ID. 
5:55 — Запит на рейтинг команди. 
6:35 — Запит на створення події. 
7:20 — Запит на подію за ID. 
8:05 — Запит на список подій за ID користувача та/чи команди. 
8:20 — Запит на аналітику за ID команди. 
9:00 — Запит на сканування бейджа. 
9:20 — Запит на рейтинг для IoT. 
9:35 — Запит на створення нового рівня до команди. 
10:15 — Запит на створення нового бейджа до команди. 
10:45 — Запит на створення нового типу подій до команди.


ДОДАТОК Б

Рисунок Б.1 – Загальна діаграма класів


Рисунок Б.2 – UML-діаграма прецедентів користувачів


Рисунок Б.3 – UML-діаграма прецедентів Менеджера



Рисунок Б.4 – UML-діаграма прецедентів Користувача


Рисунок Б.5 – UML-діаграма прецедентів Адміністратора


Рисунок Б.6 – UML-діаграма прецедентів IoT-пристрія


Рисунок Б.7 – ER-діаграма


Рисунок Б.8 – Схема реляційної бази даних


Рисунок Б.9 – Схема реляційної бази даних в SSMS

2


