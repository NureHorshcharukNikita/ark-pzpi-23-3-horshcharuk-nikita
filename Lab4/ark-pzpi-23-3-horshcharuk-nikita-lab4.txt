Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 


Кафедра програмної інженерії
 


Звіт
з лабораторної роботи №4
з дисципліни «Аналіз та рефакторинг коду»






Виконав:                                                           	     Перевірив:
ст. гр. ПЗПІ-23-3                                    	       	     ст. викл. Сокорчук І. П.
Горщарук Н. С.







Харків 2025
1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень101.12.20250.1Оформлено повністю текстовий звіт204.12.20250.2Додано посилання на відео

2 ЗАВДАННЯ
     Згідно з методичними вказівками до лабораторної роботи №4 необхідно:
1. Спроєктувати архітектуру IoT-клієнта Elevate, включаючи модулі:
* робота з мережею;
* робота з NFC/RFID (зчитування бейджа);
* взаємодія із сервером;
* відображення інформації на LED-панелі;
* модуль налаштувань.
2. Створити UML діаграму прецедентів для IoT-клієнта.
3. Розробити бізнес-логіку та функції налаштування:
* обробка сканування бейджа;
* виклики API /api/iot/scan, /api/iot/leaderboard;
* обробка помилок;
* налаштування параметрів клієнта.
4. Створити UML діаграму діяльності, що описує процес сканування та обробки відповіді.
5. Реалізувати програмний код IoT-клієнта (на основі ESP32 / Wokwi-симуляції).
6. Провести тестування IoT-клієнта.
7. Завантажити код у GitHub-репозиторій.
8. Створити відеодемонстрацію роботи IoT-клієнта та хронологічний опис.



3 ОПИС ВИКОНАНОЇ РОБОТИ
1. Створення програмної реалізації бізнес-логіки та налаштувань
     У межах роботи було реалізовано повноцінний програмний прототип IoT-клієнта на базі ESP32. Код організовано модульно, з чітким розділенням відповідальностей між компонентами (налаштування, мережа, API, зчитувач бейджів, відображення, бізнес-логіка). Це дозволяє легко замінювати апаратні та інфраструктурні частини без зміни бізнес-сценаріїв.
2. Технічний стек та архітектура реалізації
     IoT-клієнт реалізований як Arduino-скетч для ESP32 (ESP32-DOIT-DEVKIT-V1) з можливістю запуску:
* у симуляторі Wokwi;
* на реальному мікроконтролері.
     Використані технології та бібліотеки:
1. Мова та платформа: C++ / Arduino Framework для ESP32.
2. Мережа та HTTP:
* WiFi.h — керування Wi-Fi з’єднанням;
* HTTPClient.h — виконання HTTP/REST-запитів.
3. Обмін даними:
* ArduinoJson (v7.4.2) — серіалізація та парсинг JSON.
4. Візуалізація:
* Adafruit_GFX.h, Adafruit_ILI9341.h + SPI.h — робота з TFT-дисплеєм ILI9341 (240×320).
5. Структура проєкту:
* окремі модулі у вигляді заголовкових файлів (ConfigManager, WiFiManager, ApiClient, BadgeReader, LedDisplay, CoreLogic, LeaderboardButton);
* файл main.cpp з функціями setup() та loop(), де виконується ініціалізація та основний цикл роботи пристрою.
3. Модуль ConfigManager (керування налаштуваннями)
     ConfigManager відповідає за конфігурацію пристрою та основні параметри роботи.
     Зберігає:
* WIFI_SSID, WIFI_PASSWORD — параметри Wi-Fi мережі;
* API_BASE_URL — базова адреса серверу Elevate (наприклад, http://192.168.0.77:5181);
* DEVICE_KEY — унікальний ключ пристрою з таблиці Devices;
* currentMode — режим роботи:
SCAN_MODE — сканування бейджів;
DASHBOARD_MODE — режим лідерборду;
* dashboardUpdateInterval — інтервал оновлення лідерборду.
     Основні функції:
* ініціалізація параметрів за замовчуванням (initialize());
* логічний вибір режиму роботи;
* можливість розширення:
збереження параметрів у EEPROM / файловій системі (SPIFFS/LittleFS);
конфігурація через веб-інтерфейс у режимі access point.
     У навчальному прототипі всі параметри зберігаються як константи в constants.h у просторі імен Config::.
4. Модуль WiFiManager (мережеве підключення)
     WiFiManager інкапсулює всю логіку підключення до Wi-Fi та контролю стану мережі.
     Функціональність:
1. Підключення до мережі (connect()):
* використання параметрів з ConfigManager;
* перевірка поточного стану перед новою спробою;
* цикл повторних спроб (до WIFI_MAX_ATTEMPTS = 15);
* затримка між спробами (WIFI_CONNECT_DELAY_MS = 300 мс);
* оновлення внутрішнього статусу з’єднання.
2. Гарантоване з’єднання (ensureConnection()):
* перевірка статусу Wi-Fi;
* при розриві — від’єднання та повторне підключення;
* використовується іншими модулями перед мережевими операціями.
3. Сервісні методи:
* isConnected() — перевірка стану через WiFi.status();
* гетери/сетери для внутрішнього стану, синхронізація з UI.
     Механізм захисту від надмірних спроб:
* фіксація часу останнього підключення (lastConnectionAttempt);
* мінімальний інтервал між спробами (WIFI_RETRY_INTERVAL_MS = 5000 мс) для розвантаження Wi-Fi-стека та економії енергії.
5. Модуль ApiClient (HTTP/REST-клієнт)
     ApiClient реалізує всю комунікацію з серверною частиною Elevate та приховує деталі HTTP/JSON від бізнес-логіки.
     Основні ендпоінти:
* POST{API_BASE_URL}/api/iot/scan — надсилання сканування бейджа;
* GET{API_BASE_URL}/api/iot/leaderboard?deviceKey={DEVICE_KEY} — отримання командного лідерборду.
     Ключові операції:
1. Сканування користувача (scanUser(int userId)):
* перевірка мережі через WiFiManager::ensureConnection();
* формування JSON { deviceKey, userId };
* встановлення заголовків Content-Type: application/json та таймауту (HTTP_TIMEOUT_MS = 10000 мс);
* обробка відповіді:
200 OK — парсинг JSON, заповнення структури ScanResult (id користувача/команди, ПІБ, бали, рівень, останні бейджі);
3xx — обробка редиректів (через handleRedirect());
4xx/5xx — парсинг полів message / error / title і формування зрозумілого тексту помилки;
помилки транспорту (таймаут, відмова з’єднання) — перетворення на текстові повідомлення для UI.
* повернення результату у вигляді ScanResult з ознакою успіху/помилки.
2. Отримання лідерборду (getLeaderboard(LeaderboardEntry* entries, int maxEntries)):
* перевірка Wi-Fi;
* виконання HTTP GET;
* парсинг JSON-масиву учасників;
* заповнення масиву LeaderboardEntry (позиція, ПІБ, бали, рівень);
* повернення успіху/помилки.
     ApiClient реалізує детальну обробку помилок (мережеві, протокольні, JSON-помилки) та повертає бізнес-логіці вже “очищені” результати.
6. Модуль BadgeReader (емуляція RFID/NFC-зчитувача)
     BadgeReader відповідає за отримання ідентифікатора користувача. У прототипі використовується емуляція через кнопки замість реального NFC/RFID-зчитувача.
     Апаратна частина:
* BUTTON_USER1 (GPIO 32) → userId = 1;
* BUTTON_USER2 (GPIO 33) → userId = 2;
* BUTTON_USER3 (GPIO 25) → userId = 3.
     Функції:
1. initialize():
* налаштування пінів у режим INPUT_PULLUP;
* ініціалізація внутрішніх змінних (час натиснення, останній userId);
2. readUserId():
* debounce (затримка BUTTON_DEBOUNCE_MS, додаткова перевірка стану кнопки);
* послідовне опитування кнопок;
* повернення відповідного userId або 0, якщо натиснень немає;
3. hasNewScan() — перевірка наявності нового сканування;
4. getLastUserId() — повертає останній зчитаний ідентифікатор.
     У промисловій версії цей модуль може бути замінений на роботу з MFRC522, при цьому інтерфейс readUserId() залишається незмінним.
7. Модуль LedDisplay (візуалізація на TFT-дисплеї)
     LedDisplay відповідає за відображення інформації на TFT-дисплеї ILI9341.
     Основні режими відображення:
1. Ініціалізація (initDisplay()):
* запуск дисплея (begin()), встановлення орієнтації (setRotation(1)), очищення екрану;
2. Показ профілю користувача (showUserProfile()):
* заголовок “PROFILE”;
* ПІБ (з обрізанням до обмеженої довжини);
* бали, рівень, останній бейдж;
3. Показ помилки (showError()):
* заголовок “ERROR”;
* автоматичний перенос тексту помилки по рядках;
4. Лідерборд (showLeaderboard()):
* заголовок “LEADERBOARD”;
* до 5 записів у форматі: {rank}. {name} {points}pt;
5. Режим очікування (showWaitingMessage()):
* текст “Waiting for scan…”;
6. Етапи завантаження (showLoadingStep()):
* назва кроку + індикатор прогресу (0–100%);
7. Офлайн-інформація (showOfflineInfo()):
* статус Wi-Fi, IP-адреса;
* uptime пристрою;
* статистика успішних/неуспішних сканувань;
* поточний режим роботи.
     Додатково модуль містить допоміжні функції для обрізання рядків, ведення статистики сканувань та її ініціалізації.
8. Модуль LeaderboardButton (швидкий виклик лідерборду)
     LeaderboardButton — окремий модуль для обробки натискання кнопки швидкого перегляду лідерборду.
     Особливості:
* використовується пін BUTTON_LEADERBOARD (GPIO 26);
* застосовується debounce за тим самим принципом, що в BadgeReader;
* метод isPressed() повертає true лише один раз на фактичне натискання, завдяки внутрішньому прапорцю wasPressed.
9. Модуль CoreLogic (бізнес-логіка IoT-клієнта)
     CoreLogic поєднує всі модулі у єдиний цикл та реалізує сценарії:
Режим сканування (handleScanMode()):
1. перевірка кнопки лідерборду → за потреби виклик showLeaderboardOnDemand() (отримання та показ лідерборду);
2. обробка нового сканування:
* BadgeReader::hasNewScan() / getLastUserId();
* виклик ApiClient::scanUser(userId);
3. обробка результату:
* при успіху — інкремент статистики, показ профілю, пауза, повернення до очікування;
* при помилках:
мережеві — показ офлайн-екрану;
інші — показ детального тексту помилки.
4. періодичне оновлення екрану очікування (“Waiting for scan…”).
Режим лідерборду (handleDashboardMode()):
1. раз на налаштований інтервал:
* отримання лідерборду через ApiClient::getLeaderboard();
* відображення списку на дисплеї;
2. у випадку помилок — показ офлайн-інформації.
Головний виклик (run()):
1. вибір потрібного сценарію залежно від ConfigManager::currentMode.
10.  Точка входу: функції setup() та loop()
     setup() виконує одноразову ініціалізацію пристрою:
1. запуск послідовного порту (Serial.begin(115200));
2. скидання статистики сканувань (LedDisplay::initializeStats());
3. покрокова індикація завантаження через showLoadingStep():
* налаштування конфігурації (ConfigManager);
* ініціалізація дисплея;
* ініціалізація кнопок (BadgeReader, LeaderboardButton);
* підключення до Wi-Fi (WiFiManager);
4. вибір стартового екрану залежно від режиму:
* SCAN_MODE — “Waiting for scan…”;
* DASHBOARD_MODE — екран офлайн-інформації.
     loop() реалізує основний цикл:
* періодичний моніторинг стану Wi-Fi (через WiFiManager);
* виклик CoreLogic::run() для виконання бізнес-логіки;
* невелика затримка (delay(LOOP_DELAY_MS)) для стабільної роботи.
11.  Структури даних
     Для взаємодії між модулями використовуються прості структури:
1. ScanResult — результат сканування:
* ідентифікатори користувача та команди;
* ПІБ, бали, назва рівня;
* масив останніх бейджів;
* ознака успіху та текст помилки.
2. LeaderboardEntry — запис лідерборду:
* позиція в рейтингу;
* userId, ПІБ;
* кількість балів;
* рівень.
     Ці структури ізольовують бізнес-дані від конкретної реалізації протоколу/JSON.
12.  Обробка помилок та відмовостійкість
     У реалізації враховано кілька рівнів захисту:
1. Мережевий рівень:
* повторні спроби підключення до Wi-Fi;
* таймаути HTTP-запитів;
* обробка типових помилок з’єднання (відмова, таймаут, втрата зв’язку).
2. Рівень HTTP/серверу:
* аналіз кодів статусу;
* парсинг JSON-повідомлень про помилку;
* надання користувачу зрозумілих текстових повідомлень.
3. Рівень вводу:
* debounce кнопок;
* базова валідація даних перед відправкою.
4. Відмовостійкість в цілому:
* пристрій залишається працездатним без мережі (показ офлайн-статусів);
* ведеться статистика сканувань;
* користувач може бачити актуальний стан навіть при збоях серверу.
13.  Особливості реалізації та можливості розширення
     Ключові архітектурні рішення:
* використання статичних методів і змінних → відсутність зайвих об’єктів, економія пам’яті;
* модульний підхід → легка заміна:
емуляції RFID на реальний зчитувач;
TFT-дисплея на LED-матрицю;
HTTP-транспорту на MQTT;
* енергоефективність:
короткі періоди активної роботи дисплею;
відсутність важких обчислень у loop();
можливість додати режим глибокого сну між скануваннями.

4 ВИСНОВКИ
     У ході виконання лабораторної роботи було:
* спроєктовано архітектуру IoT-клієнта Elevate;
* створено UML-діаграму прецедентів та діяльності;
* реалізовано ключову бізнес-логіку: сканування бейджа, виклики API, відображення профілю, відображення лідерборду;
* чітке розділення відповідальностей між модулями;
* готовність до промислового розширення (реальний NFC/RFID, інші протоколи, складніша візуалізація);
* розроблено прототип IoT-клієнта на ESP32;
* виконано тестування роботи та інтеграції з сервером;
     Попри використання емуляції зчитувача на базі кнопок, логіка побудована так, що перехід до фізичного RFID/NFC-модуля потребує мінімальних змін — переважно на рівні одного модуля BadgeReader, без втручання в бізнес-логіку.
     Розроблений IoT-клієнт є важливою складовою гейміфікаційної системи Elevate та забезпечує фізичну взаємодію користувача з цифровою платформою.


5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. ДСТУ 8302:2015. Бібліографічне посилання. Загальні положення та правила складання.
2. Vision & Scope документ для програмної системи “Elevate”
3. Звіт до лабораторної роботи №3.
4. Microsoft .NET Documentation: ASP.NET Core, Entity Framework Core – https://learn.microsoft.com/en-us/dotnet/
5. Wokwi – Online Arduino and ESP32 Simulator – https://wokwi.com/


ДОДАТОК А
Відеозапис
Відеозапис лабораторної роботи: https://www.youtube.com/watch?v=lkW6SwZbNCM

Хронологічний опис відеозапису:
0:00 — Вступ. 
1:05 — Технічний стек та архітектура реалізації. 
1:55 — Модуль ConfigManager. 
2:25 — Модуль WiFiManager. 
2:55 — Модуль ApiClient. 
3:35 — Модуль BadgeReader. 
4:00 — Модуль LedDisplay. 
4:30 — Модуль LeaderboardButton. 
4:45 — Модуль CoreLogic. 
5:10 — Функції setup() та loop(). 
5:30 — Структури даних. 
5:45 — Обробка помилок та відмовостійкість. 
6:00 — Особливості реалізації та можливості розширення. 
6:15 — Компоненти та параметри IoT-пристрія. 
7:35 — Пояснення відображення на екрані. 
8:30 — Тестування IoT-пристрія.

ДОДАТОК Б

Рисунок Б.1 – UML-діаграма прецедентів IoT-пристрія


Рисунок Б.2 – Діаграма діяльності IoT-пристрія відображення профілю користувача


Рисунок Б.3 – Діаграма діяльності IoT-пристрія відображення лідерборду


Рисунок Б.4 – Діаграма діяльності IoT-пристрія підключення до мережі та відправка сканування на сервер

2


